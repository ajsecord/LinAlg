<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN">
<html><head><meta http-equiv="Content-Type" content="text/html;charset=iso-8859-1">
<title>LinAlg: Introduction</title>
<link href="doxygen.css" rel="stylesheet" type="text/css">
</head><body>
<!-- Generated by Doxygen 1.3.4 -->
<div class="qindex"><a class="qindexHL" href="index.html">Main&nbsp;Page</a> | <a class="qindex" href="namespaces.html">Namespace List</a> | <a class="qindex" href="hierarchy.html">Class&nbsp;Hierarchy</a> | <a class="qindex" href="annotated.html">Class&nbsp;List</a> | <a class="qindex" href="namespacemembers.html">Namespace&nbsp;Members</a> | <a class="qindex" href="functions.html">Class&nbsp;Members</a></div>
<h1>Introduction </h1>
<p>
<h2><a class="anchor" name="intro">
Introduction to LinAlg</a></h2>
<a class="el" href="namespaceLinAlg.html">LinAlg</a> 3.0 is a simple C++ template vector and matrix library, generally intended for 2D, 3D, 4D computations in computer graphics and related fields. The objects are fixed-size and the storage is dense, resulting in good optimization opportunities for the compiler.<p>
Vectors and matrices are stored as dense arrays of values. All basic types are supported for the underlying storage type, and by default, the library includes instantiations for <code>float</code>, <code>double</code>, <code>int</code> and <code>unsigned</code> <code>int</code> in two, three and four dimensions.<h2><a class="anchor" name="changes_intro">
Changes since version 2.0</a></h2>
<h3><a class="anchor" name="removed_dimension">
Removal of the dimension template parameter</a></h3>
In version 2, each of Vector and Matrix were templated on both the underlying data type and the dimension, for example, LinAlg::Vector&lt;float,2&gt;. However, using this approach, it is difficult to provide constructors such as Vector(float x, float y). The current version generates source for each dimension separately, for example, LinAlg::Vec2&lt;float&gt;. Note that the names were shortened from Vector to Vec and Matrix to Mat. The library provides source for both Vec and Mat in dimensions 2, 3, and 4. If you need different dimensions, they are trivially generated using <code>src/generate</code>.cpp. <em>Please note that Vec?.h and Mat?.h are now generated files, and should not be edited directly.</em> Edit <code>VecTemplate</code>.* and <code>MatTemplate</code>.* instead and re-run <code>generate</code>.<p>
Note that this means that each individual header (<a class="el" href="Vec2_8h.html">Vec2.h</a>, <a class="el" href="Vec3_8h.html">Vec3.h</a>, etc.) should be smaller and faster to compile. Currently the headers only pull in <code>&lt;iosfwd&gt;</code> and <code>&lt;string&gt;</code>, the latter could be removed if the <code>description()</code> member is not needed.<p>
<code>Convenience.h</code> and its <code>build()</code> functions has been removed in favor of using each classes' constructor directly. Similarily, the <code>convert()</code> methods (for converting from a class of different underlying type) have been replaced by the constructors.<h3><a class="anchor" name="zero_init">
Zero initialization by the default constructors</a></h3>
Some users wanted the default constructor to automatically zero out the object's data, making the default constructor the same as explicitly assigning from the zero vector. This is a speed/safety tradeoff which can be controlled by defining the preprocessor macro <code>LINALG_DEFAULT_INITIALIZE_TO_ZERO</code>. If this macro is not defined then vectors and matrices are not initialized in the default constructor. If this macro is defined, then they are intialized to zero.<h2><a class="anchor" name="dependencies">
Dependencies</a></h2>
The code is self-contained except for the optional ability to call the <a href="http://www.netlib.org/lapack/">LAPACK</a> numerical library to determine the eigenvalues and eigenvectors for matrices with dimension greater than three. For 2D and 3D matrices, it is more efficient and feasible to compute the eigenvalues and eigenvectors "by hand", so these do not need LAPACK.<p>
On Unix-type systems, link against the system-supplied LAPACK library, ususally called <code>liblapack</code> or, on OS X, the <code>vecLib</code> framework. Under Windows, the easiest way to get LAPACK is to download Intel's <a href="http://www3.intel.com/cd/software/products/asmo-na/eng/307757.htm">MKL</a> library, which includes LAPACK. Unfortunately, the MKL is commercial software, though it does have a free evaluation.<p>
If you don't care about computing eigenvalues and eigenvectors for dimensions four and above, then you can define the macro <code>LINALG_NO_LAPACK</code>, which will remove the requirement to link against LAPACK and make <a class="el" href="namespaceLinAlg.html">LinAlg</a> completely self-contained.<h2><a class="anchor" name="build">
Included build environments</a></h2>
There are projects to build the library and its test suite for the following integrated development environments:<ul>
<li>Apple's XCode 3.x in <code>ide/XCode 3</code>. This should be compatible with XCode 2.x, but I can't verify this.</li><li>Microsoft Visual Studio Express 2005, also known as Visual Studio 8.0, in <code>ide/VisualStudio8.0</code>.</li></ul>
<h2><a class="anchor" name="test">
Test suite and examples</a></h2>
There is a test suite in <code>src/run_tests.cpp</code> that tests most aspects of the library and a tiny example in <code>src/example.cpp</code> that demonstrates "normal" usage. You should be able to build and run these to verify that everything is working. The included IDE project files include targets to do this for you.<h2><a class="anchor" name="template">
Template libraries and linking</a></h2>
By default, <a class="el" href="namespaceLinAlg.html">LinAlg</a> provides <code>Vec</code> and <code>Mat</code> for the types <code>float</code>, <code>double</code>, <code>int</code> and <code>unsigned</code> <code>int</code> in two, three and four dimensions. If this is all you need, then you can skip this section. If you need <a class="el" href="namespaceLinAlg.html">LinAlg</a> to not generate these default types, or if you need to use a custom type, then you should read this section.<p>
C++ template libraries are different from standard libraries. A C++ template does not actually generate code; it's a pattern that tells the compiler how to generate code when the user actually creates an instantiation of the class.<p>
A normal class usage might look like this: <div class="fragment"><pre><span class="comment">// In the header List.h</span>
<span class="keyword">class </span>List {
    <span class="keyword">public</span>:
    <span class="keywordtype">void</span> print();
    ...
};

<span class="comment">// In the implementation List.cpp</span>
<span class="preprocessor">#include "List.h"</span>
<span class="keywordtype">void</span> List::print() {
    ...
}

<span class="comment">// In some program</span>
<span class="preprocessor">#include "List.h"</span>
<span class="keywordtype">int</span> main() {
    List list;
    list.print();
}
</pre></div>The implementation file is compiled once and the resulting object code for <code>print()</code> is stashed away into an object file <code>List.o</code>. When the main program is compiled, then the compiler generates a reference to the body of <code>List::print()</code>, then the linker puts it all together into a runnable program. It works because the linker can find the implementation of <code>List::print()</code> in <code>List.o</code>. The important point is that when the compiler is compiling the main program, it doesn't have the implementation of <code>List::print()</code> (it's only read <code>List.h</code>), but it can generate a reference to it and trust that the linker will find it.<p>
If we change <code>List</code> to depend on a template parameter <code>T</code>, we might start with this: <div class="fragment"><pre><span class="comment">// In the header List.h</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; 
<span class="keyword">class </span>List {
    <span class="keyword">public</span>:
    <span class="keywordtype">void</span> print();
    ...
};

<span class="comment">// In the implementation List.cpp</span>
<span class="preprocessor">#include "List.h"</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keywordtype">void</span> List&lt;T&gt;::print() {
    ...
}

<span class="comment">// In some program</span>
<span class="preprocessor">#include "List.h"</span>
<span class="keywordtype">int</span> main() {
    List&lt;int&gt; list;
    list.print();
}
</pre></div>If you were to try to compile this together, however, you would get an error because the linker would not be able to find the implementation of <code>List&lt;int&gt;::print()</code>. When the compiler compiles the main program, it reads only <code>List.h</code>, not <code>List.cpp</code>. So when it sees the declaration <code>List&lt;int&gt; list</code>, it does its copy and paste trick replacing <code>T</code> for <code>int</code> in the <code>List</code> class. However, since it doesn't have the implementation of <code>print()</code>, all it can do is generate references to <code>List&lt;int&gt;::print()</code>, just like in the non-template version. So far, so good. However, the problem is that when the compiler compiles <code>List.cpp</code>, it has no clue what types might get substituted for the type <code>T</code>, and so it generates <em>no actual object code at all</em>. So <code>List.o</code> has no object code for <code>List&lt;int&gt;::print()</code> and the linker will fail to produce a working program.<p>
A related problem is inline functions: for the compiler to insert the body of an inlined function into its caller, it must have the entire definition at hand when the function is called. Hence inline functions must always be placed in full in the header. Most of <a class="el" href="namespaceLinAlg.html">LinAlg</a> functions are very simple (generally consisting of a single loop over the elements) and are inlined and thus defined fully in the header. However, some significantly-large ones are not: for example, input/output and those that call the standard numerical library <a href="http://www.netlib.org/lapack/">LAPACK</a>. The rest of this discussion pertains to these non-inlined functions.<p>
In our simple example, there are currently two solutions: the first, and most common, is to simply append the definitions from <code>List.cpp</code> at the end of <code>List.h</code> as inlined functions and forget about <code>List.cpp</code>. Then, when the compiler compiles the main program, <code>List.h</code> contains the complete code for <code>List</code> and the declaration <code>List&lt;int&gt; list</code> generates object code for all of <code>List&lt;int&gt;</code>, including <code>List&lt;int&gt;::print()</code>. This is a "header-only" library, but it has one major drawback: the header file can get enormous. Every file that includes <code>List.h</code> has to read and parse the entire implementation of <code>List!</code> You are in effect not just compiling <code>List.cpp</code> once, but <em>every time</em> you compile a file that uses <code>List</code>. Remember also that while header files can often forward-declare or otherwise avoid including other headers, the actual implementation always needs full definitions and headers for everything it uses. This is a major reason why many C++ libraries are so horribly slow to compile against. <em>Slow compilation times mean low programmer productivity.</em><p>
The other solution is to force the compiler to generate object code for <code>List&lt;int&gt;</code> while it is compiling <code>List.cpp</code>. C++ has a mechanism for this, it is called <em>explicit instantiation</em>. With explicit instantiation, our example becomes: <div class="fragment"><pre><span class="comment">// In the header List.h</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt; 
<span class="keyword">class </span>List {
    <span class="keyword">public</span>:
    <span class="keywordtype">void</span> print();
    ...
};

<span class="comment">// In the implementation List.cpp</span>
<span class="preprocessor">#include "List.h"</span>
<span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<span class="keywordtype">void</span> List&lt;T&gt;::print() {
    ...
}
<span class="keyword">template</span> <span class="keyword">class </span>List&lt;int&gt;;   <span class="comment">// Explicit instantiation</span>

<span class="comment">// In some program</span>
<span class="preprocessor">#include "List.h"</span>
<span class="keywordtype">int</span> main() {
    List&lt;int&gt; list;
    list.print();
}
</pre></div>When the compiler compiles <code>List.cpp</code> and reads the explicit instantiation, it generates object code for all of <code>List&lt;int&gt;</code> and places them in <code>List.o</code>, since it has all the definitions it needs at that point. The linker will end up finding the object code for <code>List&lt;int&gt;::print()</code> in <code>List.o</code> and will generate a working program. The upside of this solution is that the implementation is only compiled once, not multiple times and the header gets to stay as small as possible. The downside is that you somehow have to magically know what types you will be using in your program and insert the explicit instantions into the implementation code. For general libraries, this is tricky or impossible. However, for a relatively well-characterized library like a linear algebra library, however, we can probably guess.<p>
<a class="el" href="namespaceLinAlg.html">LinAlg</a> uses this second solution to keep the header files as small as possible. By default we instantiate the templates for the <code>float</code>, <code>double</code>, <code>int</code>, and <code>unsigned</code> types. When compiling the library, you can control the explicit instantiations in two ways:<ul>
<li>To avoid generating these default instantiations, you can define the preprocessor macro <code>LINALG_SKIP_DEFAULT_INSTANTIATIONS</code>.</li><li>To instantiate a Vec and Mat with your own type, define the preprocessor macros <code>LINALG_INSTANTIATE_USER_TYPE</code>. For example, define <div class="fragment"><pre>LINALG_INSTANTIATE_USER_TYPE=<span class="keywordtype">long</span> <span class="keywordtype">double</span>
</pre></div>to generate vectors and matrices that use <code>long double</code>'s as storage. If you need more than a single type, edit VectorTemplate.cpp and MatrixTemplate.cpp, add your types to the end, and re-run <code>generate</code>.</li></ul>
<h2><a class="anchor" name="problems">
Known Problems</a></h2>
<h3><a class="anchor" name="VisualStudioExpress8">
Visual Studio Express C++ 8.0</a></h3>
Visual Studio Express 8.0 with service pack 1 applied has a known bug when compiling some member functions. If you get an error C2244 "unable to match function definition" when compiling Vector.cpp, you need to apply the hotfix listed in the following knowledge base article from Microsoft:<p>
<a href="http://support.microsoft.com/default.aspx/kb/930198">http://support.microsoft.com/default.aspx/kb/930198</a><p>
You should only apply this hotfix if you are actually getting the C2244 error.<h2><a class="anchor" name="changes">
Changes</a></h2>
<h3><a class="anchor" name="_0">
Changes from version 2.0</a></h3>
<ul>
<li>Removed the dimension template parameter in favor of generating the source directly. Edit VecTemplate.* and MatTemplate.* and re-run <code>generate</code> to make changes to any of Vec?.h or Mat?.h.</li><li>Removed Convenience.h, the build() functions, and the convert() members. The constructors now provide this functionality.</li><li>Added optional zero-initialization in the default constructors.</li><li>Remove the deprecated <code>operator</code>[] from the vector classes.</li></ul>
<h3><a class="anchor" name="_0">
Changes from version 2.0</a></h3>
<ul>
<li>Added a test suite in <code>run_tests.cpp</code> </li><li>Added <code>Vector::unit()</code> for creating unit vectors</li><li>Added <code>Vector::proj()</code> to project one vector onto another</li><li>Added code documentation</li><li>Added Visual Studio 7/8 project files</li><li>Dropped support for the legacy constructors that took an argument that specified the size of the vector/matrix.</li><li>Removed <code>Vector::rand()</code>, since random number generation is very application-specific and shouldn't be in a library.</li><li>Removed the <code>buildVec()</code> and <code>buildMat()</code> routines and replaced with the unified <code>build()</code> routines in <code>Convenience.h</code>.</li><li>Added preprocessor logic for template instantiations and user types.</li><li>Added preprocessor logic to remove LAPACK calls. </li></ul>
<hr>
<p>
    <small>
        <em>
            &copy; 2005-2008 <a style="text-decoration:none" href="http://mrl.nyu.edu/~ajsecord/">Adrian Secord</a>.
        </em>
    </small>
<p>
