// Warning: this file was generated from src/LinAlg/MatTemplate.h.  Do not edit if you value your changes!

/*
 * LinAlg 3.0: fixed-sized vector and matrix library for small dimensions with optional LAPACK bindings.
 * Mat3.h
 * Contact: http://www.google.com/search?q=%22Adrian+Secord%22
 * Copyright 2005-2008 Adrian Secord.
 */

#ifndef LINALG_MAT3_H
#define LINALG_MAT3_H

#include <iosfwd>
#include <string>

#include <LinAlg/Vec3Fwd.h>
#include <LinAlg/Mat3Fwd.h>

namespace LinAlg {

//
// Pre-declare template friends
//

/// Return the negation of a matrix.
template <typename T>
Mat3<T> operator-(const Mat3<T>& u);

/// Add two matrices together.
template <typename T>
Mat3<T> operator+(const Mat3<T>& u, const Mat3<T>& v);

/// Subtract two matrices.
template <typename T>
Mat3<T> operator-(const Mat3<T>& u, const Mat3<T>& v);

/// Multiply two matrices.
template <typename T>
Mat3<T> operator*(const Mat3<T>& u, const Mat3<T>& v);
    
/// Right-multiply a matrix by a scalar.
template <typename T>
Mat3<T> operator*(const Mat3<T>& u, const T s);

/// Left-multiply a matrix by a scalar.
template <typename T>
Mat3<T> operator*(const T s, const Mat3<T>& u);

/// Divide a matrix by a scalar.
template <typename T>
Mat3<T> operator/(const Mat3<T>& u, const T s);
    
/// Multiply a vector by a matrix.
template <typename T>
Vec3<T> operator*(const Mat3<T>& u, const Vec3<T>& v);

/// Exact equality -- use with caution on floating-point base types.
template <typename T> 
bool operator==(const Mat3<T>& u, const Mat3<T>& v);

/// Exact inequality -- use with caution on floating-point base types.
template <typename T> 
bool operator!=(const Mat3<T>& u, const Mat3<T>& v);

/// Per-element minimum.
template <typename T>
Mat3<T> min(const Mat3<T>& u, const Mat3<T>& v);

/// Per-element maximum.
template <typename T>
Mat3<T> max(const Mat3<T>& u, const Mat3<T>& v);


/// \class Mat3 Mat3.h <LinAlg/Mat3.h>
/// A linear algebra matrix class of fixed type and size 3.
template <typename T>
class Mat3 {
    public:
    /// This type
    typedef Mat3<T> self_type;
    
    /// The vector type of the same dimension.
    typedef Vec3<T> vec_type;

    /// The underlying data type
    typedef T value_type;
    
    /// The number of dimensions
    enum { num_dims = 3 };

    /// The number of elements
    enum { num_elements = 3 * 3 };
    
    /// An iterator
    typedef T* iterator;
    
    /// A constant iterator.
    typedef const T* const_iterator;
    
    
    /// Create an uninitialized matrix.
    Mat3();

    /// Create a matrix from named values.
    Mat3(const T v00, const T v10, const T v20, const T v01, const T v11, const T v21, const T v02, const T v12, const T v22);
    
    /// Copy another matrix of possibly a different type.
    template <typename Other>
    Mat3(const Mat3<Other>& m);
    
    /// Assign another matrix to this matrix.
    Mat3& operator=(const Mat3& m);

    /// Read-only element access.
    const T& operator()(const unsigned i, const unsigned j) const;
    
    /// Read-write element access.
    T& operator()(const unsigned i, const unsigned j);

    /// Direct read-only access to the underlying m_data.  The elements are stored densely
    /// in column-major order.
    const T* data() const;
    
    /// Direct read-write access to the underlying m_data.  The elements are stored densely
    /// in column-major order.
    T* data();

    /// Get a read-only iterator to the first element.
    const_iterator begin() const;
    
    /// Get a read-write pointer to the first element.
    iterator begin();
    
    /// Get a read-only iterator to past the last element.
    const_iterator end() const;
    
    /// Get a read-write iterator to past the last element.
    iterator end();
    
    /// The number of rows.
    unsigned size1() const;
    
    /// The number of columns.
    unsigned size2() const;

    /// Limit each element to the range [l.first, l.second]
    void limit(const std::pair<T,T>& l);
    
    /// Limit each element to the range [lower, upper]
    void limit(const T lower, const T upper);
    
    /// Limit element (i,j) to the range [lower(i,j), upper(i,j)]
    void limit(const Mat3& lower, const Mat3& upper);
    
    /// Return the sum of all the elements.
    T sum() const;
    
    /// Return the product of all the elements.
    T prod() const;
    
    /// Return the transpose of this matrix.
    Mat3 trans() const;
    
    /// Get the \c i'th column of the matrix.
    Vec3<T> getCol(const unsigned i) const;
    
    /// Set the \c i'th column of the matrix.
    void setCol(const unsigned i, const Vec3<T>& v);

    /// Get the \c i'th row of the matrix.
    Vec3<T> getRow(const unsigned i) const;

    /// Set the \c i'th row of the matrix.
    void setRow(const unsigned i, const Vec3<T>& v);

    /// Compute the eigenvalues and eigenvectors.
    /// The eigenvectors are stored as the columns of \c vectors.
    void eigs(Vec3<T>& values, Mat3& vectors) const;

    /// Compare entries with another matrix, within eps
    bool equal(const Mat3<T>& v, const T eps) const;

    /// Add another matrix to this one.
    Mat3& operator+=(const Mat3& m);

    /// Subtract another matrix from this one.
    Mat3& operator-=(const Mat3& m);
    
    /// Multiply this matrix by a scalar value.
    Mat3& operator*=(const T d);
    
    /// Divided this matrix by a scalar value.
    Mat3& operator/=(const T d);

    // Dear god the things you have to do to get a templated friend function
    friend Mat3 operator-<>(const Mat3& u);
    friend Mat3 operator+<>(const Mat3& u, const Mat3& v);
    friend Mat3 operator-<>(const Mat3& u, const Mat3& v);
    friend Mat3 operator*<>(const Mat3& u, const Mat3& v);
    friend Mat3<T> operator* <>(const Mat3<T>& u, const T s);
    friend Mat3<T> operator* <>(const T s, const Mat3<T>& u);
    friend Mat3<T> operator/ <>(const Mat3<T>& u, const T s);
    friend Vec3<T> operator*<>(const Mat3& m, const Vec3<T>& v);
    friend bool operator== <>(const Mat3& u, const Mat3& v);
    friend bool operator!= <>(const Mat3& u, const Mat3& v);
    friend Mat3 min<>(const Mat3& u, const Mat3& v);
    friend Mat3 max<>(const Mat3& u, const Mat3& v);

    /// Return the zero matrix.
    static const Mat3& zero();
    
    /// Return the identity matrix.
    static const Mat3& ident();

    /// Calculate the inverse of a matrix from its eigenvalues and 
    /// eigenvectors.
    static Mat3 inverse(const Vec3<T>& values, const Mat3& vectors);

    /// Return a description like "2D float", useful for debugging and messages.
    static std::string description();
    
    protected:
    T m_data[3 * 3];                                      ///< The element storage.
};

    
//
// Global functions
//

/// Print a matrix to an output stream.
template <typename T>
std::ostream& operator<<(std::ostream& o, const Mat3<T>& m);

template <typename T>
std::istream& operator>>(std::istream& i, Mat3<T>& m);

} // namespace 

//
// Inline function definitions
//
#include <cassert>
#include <cmath>
#include <stdexcept>

namespace LinAlg {

template <typename T>
inline 
Mat3<T>::Mat3() {
#if defined(LINALG_DEFAULT_INITIALIZE_TO_ZERO)
    for (unsigned i = 0; i < 3 * 3; ++i)
        m_data[i] = 0;
#endif    
}
    
template <typename T>
inline
Mat3<T>::Mat3(const T v00, const T v10, const T v20, const T v01, const T v11, const T v21, const T v02, const T v12, const T v22) {
    m_data[0] = v00; m_data[1] = v10; m_data[2] = v20; m_data[3] = v01; m_data[4] = v11; m_data[5] = v21; m_data[6] = v02; m_data[7] = v12; m_data[8] = v22; 
}

template <typename T>
template <typename Other>
inline 
Mat3<T>::Mat3(const Mat3<Other>& m) {
    for (unsigned i = 0; i < 3 * 3; ++i) {
        m_data[i] = (T) m.m_data[i];
    }
}

template <typename T>
inline 
Mat3<T>& Mat3<T>::operator=(const Mat3<T>& m) {
    for (unsigned i = 0; i < 3 * 3; ++i) {
        m_data[i] = m.m_data[i];
    }
    return *this;
}

template <typename T>
inline
const T& Mat3<T>::operator()(const unsigned i, const unsigned j) const {
    assert(i < 3 && j < 3);
    return m_data[j * 3 + i];
}

template <typename T>
inline
T& Mat3<T>::operator()(const unsigned i, const unsigned j) {
    assert(i < 3 && j < 3);
    return m_data[j * 3 + i];
}

template <typename T>
inline
const T* Mat3<T>::data() const {
    return m_data;
}

template <typename T>
inline
T* Mat3<T>::data() {
    return m_data;
}

template <typename T>
inline 
typename Mat3<T>::const_iterator Mat3<T>::begin() const {
    return m_data;
}

template <typename T>
inline 
typename Mat3<T>::iterator Mat3<T>::begin() {
    return m_data;
}

template <typename T>
inline 
typename Mat3<T>::const_iterator Mat3<T>::end() const {
    return m_data + 3 * 3;
}

template <typename T>
inline 
typename Mat3<T>::iterator Mat3<T>::end() {
    return m_data + 3 * 3;
}

template <typename T>
inline
unsigned Mat3<T>::size1() const {
    return 3;
}

template <typename T>
inline
unsigned Mat3<T>::size2() const {
    return 3;
}

template <typename T>
inline
void Mat3<T>::limit(const std::pair<T,T>& l) {
    for (unsigned i = 0; i < 3* 3; ++i) {
        if (m_data[i] < l.first) 
            m_data[i] = l.first;
        if (m_data[i] > l.second) 
            m_data[i] = l.second;
    }
}

template <typename T>
inline
void Mat3<T>::limit(const T lower, const T upper) {
    for (unsigned i = 0; i < 3* 3; ++i) {
        if (m_data[i] < lower) 
            m_data[i] = lower;
        if (m_data[i] > upper)
            m_data[i] = upper;
    }
}

template <typename T>
inline
void Mat3<T>::limit(const Mat3<T>& lower, const Mat3<T>& upper) {
    for (unsigned j = 0; j < 3; ++j) {
        for (unsigned i = 0; i < 3; ++i) {
            if ((*this)(i,j) < lower(i,j)) 
                (*this)(i,j) = lower(i,j);
            if ((*this)(i,j) > upper(i,j))
                (*this)(i,j) = upper(i,j);
        }
    }
}

template <typename T>
inline 
T Mat3<T>::sum() const {
    T w = 0;
    for (unsigned i = 0; i < 3* 3; ++i)
        w += m_data[i];
    return w;
}

template <typename T>
inline 
T Mat3<T>::prod() const {
    T w = 1;
    for (unsigned i = 0; i < 3* 3; ++i)
        w *= m_data[i];
    return w;
}

template <typename T>
inline 
Mat3<T>& Mat3<T>::operator+=(const Mat3<T>& m) {
    for (unsigned i = 0; i < 3 * 3; ++i)
        m_data[i] += m.m_data[i];
    return *this;
}

template <typename T>
inline 
Mat3<T>& Mat3<T>::operator-=(const Mat3<T>& m) {
    for (unsigned i = 0; i < 3 * 3; ++i)
        m_data[i] -= m.m_data[i];
    return *this;
}

template <typename T>
inline 
Mat3<T>& Mat3<T>::operator*=(const T d) {
    for (unsigned i = 0; i < 3 * 3; ++i)
        m_data[i] *= d;
    return *this;
}

template <typename T>
inline 
Mat3<T>& Mat3<T>::operator/=(const T s) {
    // Don't get too tricky -- think of T == int and s = 2.
    for (unsigned i = 0; i < 3 * 3; ++i)
        m_data[i] /= s;
    return *this;
}

template <typename T>
inline 
Mat3<T> operator-(const Mat3<T>& u) {
    Mat3<T> w(u);
    for (unsigned i = 0; i < 3 * 3; ++i)
        w.m_data[i] = -u.m_data[i];
    return w;
}

template <typename T>
inline 
Mat3<T> operator+(const Mat3<T>& u, const Mat3<T>& v) {
    Mat3<T> w(u);
    for (unsigned i = 0; i < 3 * 3; ++i)
        w.m_data[i] = u.m_data[i] + v.m_data[i];
    return w;
}

template <typename T>
inline 
Mat3<T> operator-(const Mat3<T>& u, const Mat3<T>& v) {
    Mat3<T> w(u);
    for (unsigned i = 0; i < 3 * 3; ++i)
        w.m_data[i] = u.m_data[i] - v.m_data[i];
    return w;
}
    
template <typename T>
inline
Mat3<T> operator*(const Mat3<T>& u, const T s) {
    Mat3<T> w(u);
    w *= s;
    return w;
}

template <typename T>
inline
Mat3<T> operator*(const T s, const Mat3<T>& u) {
    Mat3<T> w(u);
    w *= s;
    return w;
}

template <typename T>
inline
Mat3<T> operator/(const Mat3<T>& u, const T s) {
    Mat3<T> w(u);
    w /= s;
    return w;
}
    
template <typename T>
inline
bool operator==(const Mat3<T>& u, const Mat3<T>& v) {
    for (unsigned i = 0; i < 3 * 3; ++i)
        if (u.m_data[i] != v.m_data[i])
            return false;
    return true;
}

template <typename T>
inline
bool operator!=(const Mat3<T>& u, const Mat3<T>& v) {
    for (unsigned i = 0; i < 3 * 3; ++i)
        if (u.m_data[i] != v.m_data[i])
            return true;
    return false;
}

template <typename T>
inline
Mat3<T> min(const Mat3<T>& u, const Mat3<T>& v) {
    Mat3<T> result;
    for (unsigned i = 0; i < 3 * 3; ++i)
        result.m_data[i] = (u.m_data[i] < v.m_data[i] ? u.m_data[i] : v.m_data[i]);
    return result;
}

template <typename T>
inline
Mat3<T> max(const Mat3<T>& u, const Mat3<T>& v) {
    Mat3<T> result;
    for (unsigned i = 0; i < 3 * 3; ++i)
        result.m_data[i] = (u.m_data[i] > v.m_data[i] ? u.m_data[i] : v.m_data[i]);
    return result;
}


} // namespace

#endif
